import { Ability } from "../ability-type";
import { Vector2 } from "../../types/vector2";
import { FilterAnyUnit } from "../../../resources/filters";
import { MapPlayer, Unit, Effect } from "w3ts";
import { BUFF_ID } from "resources/buff-ids";
import { ForceEntity } from "app/force/force-entity";
import { BuffInstanceDuration } from "app/buff/buff-instance-duration-type";
import { DynamicBuffEntity } from "app/buff/dynamic-buff-entity";

const DURATION = 15;
const RADIUS = 0; //If 0, default vision radius will be used.
const REFRESH_RATE = 1;
const DESTRUCT_ID = FourCC('0000'); // <- ADD THIS WHEN IMPLEMENTED IN MAP
const SELF_SFX = "";


export class AuditoryFocusAbility implements Ability {

    private casterUnit: Unit | undefined;
    private castingPlayer: MapPlayer | undefined;
    private checkMovmentGroup = CreateGroup();
    private refreshTime = REFRESH_RATE;
    private selfEffect: Effect | undefined;
    private locationData = [];
    private destructableList = [];
    private destructableListMax = 0;
    private remainingDuration = DURATION;
    private locallyVisible: boolean;
    private effectRadius : number;

    constructor() {}

    public initialise() {
        this.casterUnit = Unit.fromHandle(GetTriggerUnit());
        this.castingPlayer = this.casterUnit.owner;
        this.selfEffect = AddSpecialEffectTarget(SELF_SFX, this.casterUnit, "head");
        this.locallyVisible = this.castingPlayer == GetLocalPlayer();
        if (RADIUS == 0) {
            this.effectRadius = BlzGetUnitIntegerField(this.casterUnit, ConvertUnitIntegerField(FourCC('usid')));
        };
        else {
            this.effectRadius = RADIUS;
        };
        return true;
    };

    public process(delta: number) {
        if (refreshTime >= REFRESH_RATE) {
            removeDestructables();
            refreshTime = 0;
            
            //Create a temporary group using the units within the effect radius
            let tempGroup = CreateGroup();
            GroupEnumUnitsInRange(
                    tempGroup, 
                    this.casterUnit.x, 
                    this.casterUnit.y, 
                    this.effectRadius, 
                    () => (
                        const fUnit = GetFilterUnit()
                        return !BlzIsUnitInvulnerable(fUnit) && !IsUnitVisible(fUnit,this.castingPlayer);
                        );
                    );
            
            //Compare temporary group with previous temporary group and delete location data for units
            //no longer in range
            ForGroup(this.checkMovementGroup, () => (
                const enumUnit = GetEnumUnit();
                GroupRemoveUnit(this.checkMovementGroup, enumUnit);
                !IsUnitInGroup(enumUnit, tempGroup) ? delete this.locationData[enumUnit.id];
                return true;
            );
            
            //Go thru the temporary group and see if they are NOT visible and moving. If both conditions are met
            //create the destructable visible only to the casting player
            //then update unit location data and add them to the checkMovementGroup
            ForGroup(tempGroup, () => (
                const enumUnit: Unit = Unit.fromEnum();
                GroupAddUnit(enumUnit,this.checkMovementGroup);
                if (this.locationData[enumUnit.id] != null && this.locationData[enumUnit.id] != Vector2.vectorFromUnit(enumUnit)) {
                    let tempDestructable = CreateDestructable(DESTRUCT_ID, enumUnit.x, enumUnit.y, 270, 1, 0);
                    ShowDestructable(tempDestructable, this.locallyVisible);
                    SetDestructableAnimation(tempDestructable, "birth");
                    this.destructableList[destructableListMax] = tempDestructable;
                    this.destructableListMax++;
                };
                this.locationData[enumUnit.id] = Vector2.vectorFromUnit(enumUnit);
                return true;
            );
            DestroyGroup(tempGroup);
        };
        else {
            this.refreshTime += delta;
        };
        this.remainingDuration -= delta;
        return this.remainingDuration > 0;
    };

    private removeDestructables() {
        for (var i = 0; i < this.destructableListMax; ++i) {
            RemoveDestructable(this.destructableList[i]);
        };
        this.destructableListMax = 0;
        return true;
    };

    public destroy() { 
        DestroyGroup(this.checkMovmentGroup);
        DestroyEffect(this.selfEffect);
        removeDestructables();
        return true; 
    };
}
