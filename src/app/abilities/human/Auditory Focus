import { Ability } from "../ability-type";
import { Vector2 } from "../../types/vector2";
import { FilterIsAlive } from "../../../resources/filters";
import { MapPlayer, Unit, Effect } from "w3ts";
import { BUFF_ID } from "resources/buff-ids";
import { ForceEntity } from "app/force/force-entity";
import { BuffInstanceDuration } from "app/buff/buff-instance-duration-type";
import { DynamicBuffEntity } from "app/buff/dynamic-buff-entity";

const DURATION = 15;
const RADIUS = 1200; //If 0, default vision radius will be used.
const REFRESH_RATE = 1;
const DESTRUCT_ID = FourCC('0000'); // <- ADD THIS WHEN IMPLEMENTED IN MAP
const SELF_SFX = "";


export class AuditoryFocusAbility implements Ability {

    private casterUnit: Unit | undefined;
    private castingPlayer: MapPlayer | undefined;
    private checkMovmentGroup = CreateGroup();
    private refreshTime = REFRESH_RATE;
    private selfEffect: Effect | undefined;
    private locationData = [];
    private destructableList = [];
    private destructableListMax = 0;
    private remainingDuration = DURATION;

    constructor() {}

    public initialise() {
        this.casterUnit = Unit.fromHandle(GetTriggerUnit());
        this.castingPlayer = this.casterUnit.owner;
        this.selfEffect = AddSpecialEffectTarget(SELF_SFX, this.casterUnit, "head");
        return true;
    };

    public process(delta: number) {
        if (refreshTime >= REFRESH_RATE) {
            removeDestructables();
            refreshTime = 0;
            let effectRadius = 0;
            if (RADIUS == 0) {
                effectRadius = BlzGetUnitIntegerField(this.casterUnit,ConvertUnitIntegerField(FourCC('usid')));
            };
            else {
                effectRadius = RADIUS;
            };
            
            let tempGroup = CreateGroup();
            GroupEnumUnitsInRange(
                    tempGroup, 
                    this.casterUnit.x, 
                    this.casterUnit.y, 
                    effectRadius, 
                    FilterIsAlive);
            GroupRemoveGroup(this.checkMovementGroup, tempGroup);
            
            let enumUnit: Unit = Unit.fromHandle(FirstOfGroup(this.checkMovementGroup));
            while (enumUnit != null) {
                GroupRemoveUnit(this.checkMovementGroup, enumUnit);
                delete this.locationData[enumUnit.id];
                enumUnit = Unit.fromHandle(FirstOfGroup(this.checkMovementGroup));
            };
            
            enumUnit = Unit.fromHandle(FirstOfGroup(tempGroup));
            while (enumUnit != null) {
                if (IsUnitVisible(enumUnit, this.castingPlayer) == false) {
                    GroupRemoveUnit(tempGroup, enumUnit);
                    GroupAddUnit(enumUnit,this.checkMovementGroup);
                    if this.locationData[enumUnit.id] != null && this.locationData[enumUnit.id] != Vector2.vectorFromUnit(enumUnit)) {
                        let tempDestructable = CreateDestructable(DESTRUCT_ID, enumUnit.x, enumUnit.y, 270, 1, 0);
                        ShowDestructable(tempDestructable, GetLocalPlayer() == this.castingPlayer);
                        SetDestructableAnimation(tempDestructable, "birth");
                        this.destructableList[destructableListMax] = tempDestructable;
                        this.destructableListMax++;
                    };
                    this.locationData[enumUnit.id] = Vector2.vectorFromUnit(enumUnit);
                    enumUnit = Unit.fromHandle(FirstOfGroup(tempGroup));
                };
            };
            DestroyGroup(tempGroup);
        };
        else {
            this.refreshTime += delta;
        };
        this.remainingDuration -= delta;
        return this.remainingDuration > 0;
    };

    private removeDestructables() {
        for (var i = 0; i < this.destructableListMax; ++i) {
            RemoveDestructable(this.destructableList[i]);
        };
        this.destructableListMax = 0;
        return true;
    };

    public destroy() { 
        DestroyGroup(this.checkMovmentGroup);
        DestroyEffect(this.selfEffect);
        removeDestructables();
        return true; 
    };
}
